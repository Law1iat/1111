<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>围住那只猫 - 简约版</title>
    <style>
        body {
            background-color: #eeeeee;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Arial', sans-serif;
            touch-action: manipulation;
        }
        #game-container {
            position: relative;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        canvas {
            cursor: pointer;
            max-width: 100%;
        }
        .ui {
            text-align: center;
            margin-bottom: 10px;
        }
        h1 { margin: 10px 0; color: #333; }
        .score { font-size: 1.2rem; color: #ff5722; font-weight: bold; }
        .btn-reset {
            margin-top: 15px;
            padding: 10px 25px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
        }
        .btn-reset:hover { background: #45a049; }
    </style>
</head>
<body>

    <div class="ui">
        <h1>围住那只猫</h1>
        <div class="score">步数: <span id="stepCount">0</span></div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="400" height="400"></canvas>
    </div>

    <button class="btn-reset" onclick="resetGame()">重新开始</button>

<script>
/**
 * 游戏配置与常量
 */
const ROWS = 9;
const COLS = 9;
const CIRCLE_RADIUS = 18;
const GAP = 5;
const OFFSET_X = 25;
const OFFSET_Y = 25;

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const stepLabel = document.getElementById('stepCount');

let grid = []; // 0: 空地, 1: 障碍物
let catPos = { x: 4, y: 4 };
let steps = 0;
let gameOver = false;

/**
 * 初始化游戏状态
 */
function resetGame() {
    grid = [];
    steps = 0;
    gameOver = false;
    catPos = { x: 4, y: 4 };
    stepLabel.innerText = steps;

    // 生成地图
    for (let i = 0; i < ROWS; i++) {
        grid[i] = [];
        for (let j = 0; j < COLS; j++) {
            // 初始随机生成几个障碍，避开中心点
            let isObstacle = Math.random() < 0.15 && !(i === 4 && j === 4);
            grid[i][j] = isObstacle ? 1 : 0;
        }
    }
    draw();
}

/**
 * 绘制函数
 */
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            // 奇数行偏移（六边形蜂窝布局核心）
            const x = OFFSET_X + c * (CIRCLE_RADIUS * 2 + GAP) + (r % 2 === 1 ? CIRCLE_RADIUS : 0);
            const y = OFFSET_Y + r * (CIRCLE_RADIUS * 2);

            // 绘制圆圈
            ctx.beginPath();
            ctx.arc(x, y, CIRCLE_RADIUS, 0, Math.PI * 2);
            
            if (grid[r][c] === 1) {
                ctx.fillStyle = '#ffaa44'; // 障碍物颜色
            } else {
                ctx.fillStyle = '#bacda3'; // 普通地块颜色
            }
            ctx.fill();
            ctx.closePath();

            // 如果是猫的位置
            if (r === catPos.y && c === catPos.x) {
                drawCat(x, y);
            }
        }
    }
}

/**
 * 画一只简单的“神经猫”
 */
function drawCat(x, y) {
    ctx.fillStyle = '#333';
    // 身体
    ctx.beginPath();
    ctx.arc(x, y, CIRCLE_RADIUS * 0.8, 0, Math.PI * 2);
    ctx.fill();
    // 耳朵
    ctx.beginPath();
    ctx.moveTo(x - 10, y - 5); ctx.lineTo(x - 12, y - 18); ctx.lineTo(x - 2, y - 10);
    ctx.moveTo(x + 10, y - 5); ctx.lineTo(x + 12, y - 18); ctx.lineTo(x + 2, y - 10);
    ctx.fill();
    // 眼睛
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x - 5, y - 2, 3, 0, Math.PI * 2);
    ctx.arc(x + 5, y - 2, 3, 0, Math.PI * 2);
    ctx.fill();
}

/**
 * 获取点击位置对应的坐标
 */
canvas.addEventListener('click', (e) => {
    if (gameOver) return;

    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const x = OFFSET_X + c * (CIRCLE_RADIUS * 2 + GAP) + (r % 2 === 1 ? CIRCLE_RADIUS : 0);
            const y = OFFSET_Y + r * (CIRCLE_RADIUS * 2);
            
            const dist = Math.sqrt((mouseX - x)**2 + (mouseY - y)**2);
            if (dist < CIRCLE_RADIUS) {
                if (grid[r][c] === 0 && !(r === catPos.y && c === catPos.x)) {
                    grid[r][c] = 1;
                    steps++;
                    stepLabel.innerText = steps;
                    moveCat();
                    draw();
                }
                return;
            }
        }
    }
});

/**
 * 猫的移动逻辑 (核心：BFS 寻路)
 */
function moveCat() {
    // 1. 检查是否已经被围死
    const path = findShortestPath(catPos.x, catPos.y);

    if (path) {
        // 如果有路，走最短路径的第一步
        catPos.x = path[1].x;
        catPos.y = path[1].y;

        // 检查猫是否逃脱（到达边界）
        if (catPos.x === 0 || catPos.x === COLS-1 || catPos.y === 0 || catPos.y === ROWS-1) {
            draw();
            setTimeout(() => alert("猫逃跑了！你输了。"), 50);
            gameOver = true;
        }
    } else {
        // 没有逃生路径，尝试随机移动到空位
        const neighbors = getNeighbors(catPos.x, catPos.y).filter(n => grid[n.y][n.x] === 0);
        if (neighbors.length > 0) {
            const next = neighbors[Math.floor(Math.random() * neighbors.length)];
            catPos.x = next.x;
            catPos.y = next.y;
        } else {
            draw();
            setTimeout(() => alert(`你成功围住了神经猫！共用了 ${steps} 步。`), 50);
            gameOver = true;
        }
    }
}

/**
 * 获取相邻坐标 (考虑六边形偏移)
 */
function getNeighbors(x, y) {
    const res = [];
    const dirs = y % 2 === 0 ? 
        [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1]] : // 偶数行
        [[-1, 0], [1, 0], [0, -1], [0, 1], [1, -1], [1, 1]];   // 奇数行

    for (let [dx, dy] of dirs) {
        const nx = x + dx, ny = y + dy;
        if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
            res.push({ x: nx, y: ny });
        }
    }
    return res;
}

/**
 * 广度优先搜索寻找通往边界的最短路径
 */
function findShortestPath(startX, startY) {
    let queue = [[{ x: startX, y: startY }]];
    let visited = new Set();
    visited.add(`${startX},${startY}`);

    while (queue.length > 0) {
        let path = queue.shift();
        let curr = path[path.length - 1];

        // 如果到达边缘，返回路径
        if (curr.x === 0 || curr.x === COLS - 1 || curr.y === 0 || curr.y === ROWS - 1) {
            return path;
        }

        let neighbors = getNeighbors(curr.x, curr.y);
        for (let next of neighbors) {
            if (grid[next.y][next.x] === 0 && !visited.has(`${next.x},${next.y}`)) {
                visited.add(`${next.x},${next.y}`);
                queue.push([...path, next]);
            }
        }
    }
    return null; // 无路可逃
}

// 启动游戏
resetGame();
</script>
</body>
</html>